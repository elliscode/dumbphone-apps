<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Connections</title>
    <link rel="stylesheet" href="../css/stylesheet.css?v=024" />
    <link rel="stylesheet" href="../css/loader.css?v=024" />
    <link rel="icon" type="image/png" href="../img/connections.favicon.png?v=024" />
<!--
  keeping a map of all GUESSES not just guess colors
  already guessed!
  close... one away
  words for success or failure    
-->
    <style>
#comment {
  position: fixed;
  top: 2px;
  left: 2px;
  width: calc(100vw - 4px);
  justify-content: center;
  align-items: center;
  display:none;
}
#comment-span {
  font-size: 16px;
  box-sizing: border-box;
  background-color: #5a594e;
  color: #fff;
  border-radius: 5px;
  padding: 4px 10px;
}
.slow-fade {
  visibility: hidden;
  opacity: 0;
  transition: visibility 0s 2s, opacity 2s linear;
}
#results {
  position: relative;
  width: calc(100vw - 16px);
  height: calc(100vh - 16px);
  margin-bottom: 8px;
  display: none;
}
#results > div {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}
#display-text {
  font-size: xx-large;
  margin-top:0px;
}
#result-blocks {
  display: flex;
  flex-direction: column;
}
.row {
  display: flex;
  flex-direction: row;
}
.result-cell {
  width: 40px;
  height: 40px;
  border-radius: 5px;
  margin: 1px;
}
#puzzle {
    display: flex;
    flex-wrap: wrap;
}
#answers {
    display: flex;
    flex-wrap: wrap;
}
.card {
    display: flex;
    margin: 1px;
    background-color: #efefe6;
    border-radius: 5px;
    user-select: none;
}
.card > div {
    width: 82px;
    height:77px;
    border-radius: 5px;
    display:flex;
    justify-content: center;
    align-items: center;
    overflow-wrap: anywhere;
    text-align: center;
    box-sizing:border-box;
    padding:5px;
}
.answer {
    display: flex;
    margin: 1px;
    background-color: #efefe6;
    border-radius: 5px;
    user-select: none;
}
.answer > div {
    width: 334px;
    height:77px;
    border-radius: 5px;
    display:flex;
    justify-content: center;
    align-items: center;
    overflow-wrap: anywhere;
    text-align: center;
    box-sizing:border-box;
    padding:5px;
}
#guesses {
    display:flex;
    margin: 5px 0px;
}
.guess {
    width: 20px;
    height: 20px;
    border-radius: 10px;
    background-color: #999;
    display: inline-block;
    margin: 1px;
}
#game-controls > button {
    display: inline-block;
    margin: 1px;
}
.chosen {
  background-color: #5a594e;
  color: #fff;
}
.green {
  background-color: #97c447;
  color: #000;
}
.yellow {
  background-color: #f9df6d;
  color: #000;
}
.blue {
  background-color: #b0c4ef;
  color: #000;
}
.purple {
  background-color: #bb81c5;
  color: #000;
}
    </style>
  </head>

  <body>

    <div id="results">
      <div>
        <p id="display-text">TEXT</p>
        <div id="result-blocks"></div>
      </div>
    </div>

    <div style="display:flex;">
      <b><a href="../index.html">Home</a></b> <span style="margin: 0px 5px;">&gt;</span> <b>connections</b>    <div style="flex-grow:1;"></div>     <button onclick="logOut(event)">Log out</button>
    </div>

    <div id="comment"><span id="comment-span"></span></div>

    <div class="panel" id="content">
      <div id="json"></div>

      <div id="puzzle"><div id="answers"></div></div>

      <div id="guesses">Mistakes Remaining: <div class="guess"></div><div class="guess"></div><div class="guess"></div><div class="guess"></div></div>

      <div id="game-controls"><button>Shuffle</button><button onclick="deselectAll(event);">Deselect All</button><button onclick="checkGuess(event);">Submit</button></div>
    </div>
    <script src="../js/utils.js?v=024"></script>
    <script src="../js/env.js"></script>
    <script>
const TEXT = ["Perfect!","Great!","Solid!","Phew!","Next Time!"];
const COLORS = ['green', 'yellow', 'blue', 'purple'];
const json = document.getElementById("json");
const puzzle = document.getElementById("puzzle");
const answers = document.getElementById("answers");
const gameControls = document.getElementById("game-controls");
const guesses = document.getElementById("guesses");
const results = document.getElementById("results");
const displayText = document.getElementById("display-text");
const resultBlocks = document.getElementById("result-blocks");
const comment = document.getElementById("comment");
const commentSpan = document.getElementById("comment-span");
function getThePuzzle() {
    let dateValue = getTodayOrUrlParam();
    let url = API_DOMAIN + "/one-offs/get-connections";
    let xmlHttp = new XMLHttpRequest();
    xmlHttp.open("POST", url, true); // false for synchronous request
    xmlHttp.withCredentials = true;
    xmlHttp.onload = handleThePuzzle;
    xmlHttp.send(JSON.stringify({ csrf: csrfToken, date: dateValue }));
}
let puzzleSolution = undefined;
let attempts = [];
let attemptsSet = [];
function handleThePuzzle(event) {
    let result = defaultHandler(event);
    puzzleSolution = result.responseJson;
    let cards = [];
    for(let category of puzzleSolution.categories) {
        for(let card of category.cards) {
            cards.push(card);
        }
    }
    cards = cards.sort(cardSort);
    for(let card of cards) {
        drawCard(card);
    }
    applyEmulators(undefined, connectionsArrowCallback);
}
function cardSort(x, y) {
    return parseInt(x.position) - parseInt(y.position);
}
function textSort(x, y) {
    return x.localeCompare(y);
}
function drawCard(card) {
    let cardDiv = document.createElement('div');
    cardDiv.classList.add('card');
    let contentDiv = document.createElement('div');
    contentDiv.addEventListener('click', select);
    contentDiv.innerText = card.content;
    contentDiv.setAttribute('input-group-name', 'navigation')
    cardDiv.appendChild(contentDiv);
    puzzle.appendChild(cardDiv);
}
function drawAnswer(category, color) {
    let cardDiv = document.createElement('div');
    cardDiv.classList.add('answer');
    let contentDiv = document.createElement('div');
    contentDiv.innerText = category.title;
    contentDiv.setAttribute('input-group-name', 'navigation')
    cardDiv.appendChild(contentDiv);
    cardDiv.classList.add(color);
    answers.appendChild(cardDiv);
}
const connectionsPreventDefaultKeys = [
  'Backspace'
];
const connectionsPreventDefaultIfEmptyKeys = [
];
const connectionsBlurKeys = [
  'EndCall'
];
const connectionsBlurIfEmptyKeys = [
];
const connectionsInteractionKeyList = [
  'ArrowDown',
  'ArrowUp',
  'ArrowLeft',
  'ArrowRight',
  'Call'
];
function connectionsArrowCallback(event, functionHandle) {
  if ((event.target.tagName.toLowerCase() != 'textarea' && preventDefaultKeys.includes(event.key)) || (preventDefaultIfEmptyKeys.includes(event.key) && !event.target.value)) {
    event.preventDefault();
  }
  if (event.type == 'keydown' && event.target.type == 'number' && preventDefaultOnNumberInput.includes(event.key)) {
    event.preventDefault();
  }
  if (blurKeys.includes(event.key)) {
    event.target.blur();
  }
  if (event.type === 'keyup' && blurIfEmptyKeys.includes(event.key) && !event.target.value && !previousValue) {
    event.target.blur();
  }
  if (event.type === 'keydown' && connectionsInteractionKeyList.includes(event.key)) {
    // check if you are where youre supposed to be before you go
    let tooFast = (new Date()) - previousArrowTime < 100;
    if (!tooFast) {
      if (['Call'].includes(event.key)) {
        checkGuess(event);
        let inputs = Array.from(document.getElementsByClassName('navigable-input'));
        if (event.target.hasAttribute('input-group-name')) {
          const currentTarget = event.target.getAttribute('input-group-name');
          inputs = inputs.filter(x=>x.getAttribute('input-group-name') == currentTarget);
        }
        if (!document.querySelector('.selected')) {
          let newItem = inputs[0];
          newItem.focus();
          if (event.type === 'keydown' && 
              (newItem.hasAttribute('linked-item'))) {
            let checkbox = newItem.parentElement.getElementsByClassName('selectable')[0];
            checkbox.classList.add('selected');
          }
        }
      } else {
        let inputs = Array.from(document.getElementsByClassName('navigable-input'));
        if (event.target.hasAttribute('input-group-name')) {
          const currentTarget = event.target.getAttribute('input-group-name');
          inputs = inputs.filter(x=>x.getAttribute('input-group-name') == currentTarget);
        }
        let index = inputs.indexOf(event.target);
        let rows = {};
        for (let input of inputs) {
          let key = input.getBoundingClientRect().y.toString();
          if (!rows[key]) {
            rows[key] = [];
          }
          rows[key].push(input);
        }
        let rowNames = Object.keys(rows);
        let rowName = inputs[index].getBoundingClientRect().y.toString();
        let row = rows[rowName];
        let rowIndex = row.findIndex(x=>x==inputs[index]);
        if (['ArrowUp', 'ArrowDown'].includes(event.key)) {
          let foundRowNameIdx = rowNames.findIndex(x=>x==rowName);
          do {
            foundRowNameIdx = foundRowNameIdx + (['ArrowUp', 'ArrowLeft'].includes(event.key) ? -1 : 1);
            foundRowNameIdx = foundRowNameIdx < 0 ? foundRowNameIdx + rowNames.length : foundRowNameIdx;
            foundRowNameIdx = foundRowNameIdx > rowNames.length - 1 ? foundRowNameIdx - rowNames.length : foundRowNameIdx;
            rowName = rowNames[foundRowNameIdx];
          } while (!rows[rowName][rowIndex]);
        } else {
          rowIndex = rowIndex + (['ArrowUp', 'ArrowLeft'].includes(event.key) ? -1 : 1);
          rowIndex = rowIndex < 0 ? rowIndex + row.length : rowIndex;
          rowIndex = rowIndex > row.length - 1 ? rowIndex - row.length : rowIndex;
        }
        let newItem = rows[rowName][rowIndex];
        newItem.focus();
        if (event.type === 'keydown' && 
            (newItem.hasAttribute('linked-item'))) {
          let checkbox = newItem.parentElement.getElementsByClassName('selectable')[0];
          checkbox.classList.add('selected');
        }
      }
      previousArrowTime = new Date();
    }
  }
  if (event.target.tagName.toLowerCase() != 'textarea' && event.type === 'keydown' && (event.target.hasAttribute('linked-item')) && ['Enter'].includes(event.key)) {
    let button = event.target.parentElement.getElementsByClassName('selectable')[0];
    button.click();
  }
  if (functionHandle) {
    functionHandle(event);
  }
  previousValue = event.target.value;
}
function select(event) {
  if (event.target.classList.contains('chosen')) {
    event.target.classList.remove('chosen');
  } else if (document.querySelectorAll('div.chosen').length < 4) {
    event.target.classList.add('chosen');
  }
}
function checkGuess(event) {
  let chosenTiles = Array.from(document.getElementsByClassName('chosen'));
  if (chosenTiles.length == 4) {
    let chosenValues = chosenTiles.map(x=>x.innerText.trim()).sort(textSort);
    if (attemptsSet.includes(JSON.stringify(chosenValues))) {
      showMessage('Already Guessed!');
      return;
    }
    for (let i = 0; i < puzzleSolution.categories.length; i++) {
      let category = puzzleSolution.categories[i];
      let categoryValues = category.cards.map(x=>x.content).sort(textSort);
      if (JSON.stringify(chosenValues) == JSON.stringify(categoryValues)) {
        c = COLORS[i];
        attempts.push([c,c,c,c]);
        chosenTiles.forEach(x=>x.parentElement.remove());
        drawAnswer(category, c);
        succeedPuzzleIfAppropriate(event);
        return;
      }
    }
    let thisGuess = [];
    for (let chosenValue of chosenValues) {
      for (let i = 0; i < puzzleSolution.categories.length; i++) {
        let category = puzzleSolution.categories[i];
        let categoryValues = category.cards.map(x=>x.content).sort(textSort);
        if (categoryValues.includes(chosenValue)) {
          c = COLORS[i];
          thisGuess.push(c);
        }
      }
    }
    let howClose = COLORS.map(x=>thisGuess.reduce((t,y)=>t=t+(x==y),0));
    if (howClose.includes(3)) {
      showMessage('One away...');
    }
    attempts.push(thisGuess);
    attemptsSet.push(JSON.stringify(chosenValues));
    let remainingGuess = Array.from(document.getElementsByClassName('guess'));
    let removeThisOne = remainingGuess.pop();
    removeThisOne.remove();
    if (remainingGuess.length == 0) {
      failPuzzle(event);
    }
  }
}
function failPuzzle(event) {
  gameOver(false);
}
function succeedPuzzleIfAppropriate(event) {
  let appropriate = !document.querySelector('div.card');
  if (appropriate) {
    gameOver(true);
  }
}
function deselectAll(event) {
  Array.from(document.querySelectorAll('div.chosen')).forEach(x=>x.classList.remove('chosen'));
}
function gameOver(success) {
  console.log(attempts);
  gameControls.style.display = 'none';
  guesses.style.display = 'none';
  results.style.display = 'block';
  let textIndex = success ? attempts.length - 4 : TEXT.length - 1;
  displayText.innerText = TEXT[textIndex];
  for(let attempt of attempts) {
    drawAttempt(attempt);
  }
}
function drawAttempt(attempt) {
  let row = document.createElement('div');
  row.classList.add('row');
  for (let item of attempt) {
    let cell = document.createElement('div');
    cell.classList.add('result-cell');
    cell.classList.add(item);
    row.appendChild(cell);
  }
  resultBlocks.appendChild(row);
}
let fadeTimeout = undefined;
let hideTimeout = undefined;
function showMessage(messageText) {
  clearTimeout(fadeTimeout);
  clearTimeout(hideTimeout);
  commentSpan.innerText = messageText;
  comment.classList.remove('slow-fade');
  comment.style.display = 'flex';
  fadeTimeout = setTimeout(startFade, 1000);
}
function startFade(event) {
  comment.classList.add('slow-fade');
  hideTimeout = setTimeout(hideMessage, 2000);
}
function hideMessage(event) {
  comment.style.display = 'none';
}
getThePuzzle();
    </script>
  </body>
</html>
